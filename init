#!/usr/bin/env zsh
#
# This script initializes and maintains a system in a standardized format
#
# Usage:
# * TODO - install packages
# * TODO - update packages
# * config - copy or symlink conf files
# * TODO - set up hosts file
# * TODO - set up NFS connection in fstab file
#
REPO_DIR="$(realpath "$(dirname "$0")")"
source "$REPO_DIR"/global/profile
source "$REPO_DIR"/profile

PKGNAME=voskarch
BACKUP_DIR="$XDG_STATE_HOME/$PKGNAME/backup"
# directory for backing up config files before overwriting
CFG_BACKUP_DIR="$BACKUP_DIR/cfg"

prereq () {
  mkdir -p "$BACKUP_DIR" "$CFG_BACKUP_DIR"

  source "$XDG_CONFIG_HOME"/user-dirs.dirs
  # TODO: this might be doable with xdg-user-dirs-update, unclear
  mkdir -p "$XDG_DESKTOP_DIR" \
    "$XDG_DOWNLOAD_DIR" \
    "$XDG_TEMPLATES_DIR" \
    "$XDG_PUBLICSHARE_DIR" \
    "$XDG_DOCUMENTS_DIR" \
    "$XDG_MUSIC_DIR" \
    "$XDG_PICTURES_DIR" \
    "$XDG_VIDEOS_DIR"
}

init () {
  if [ "$REPO_DIR" != "$(realpath -m "$XDG_DATA_HOME/$PKGNAME")" ]; then
    while true; do
      printf ":: repo located at $REPO_DIR; move to $XDG_DATA_HOME/$PKGNAME? (y/N) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          mkdir -p "$XDG_DATA_HOME"
          cp -r "$REPO_DIR" "$XDG_DATA_HOME/$PKGNAME"
          cd "$XDG_DATA_HOME/$PKGNAME"
          rm -rf "$REPO_DIR"
          REPO_DIR="$XDG_DATA_HOME/$PKGNAME"
          print ":: new repo location: $REPO_DIR"
          break ;;
        [Nn]|No|no|"" ) break ;;
        * ) ;;
      esac
    done
  fi
}

install () {
  echo "install not implemented" >&2

  sudo pacman -Syyu
  pkgs=(pkgfile nano)
  sudo pacman -S "$pkgs[@]"
  abs

  # install vundle
  if [ ! -d "$XDG_DATA_HOME"/vim/bundle/Vundle.vim ]; then
    git clone https://github.com/VundleVim/Vundle.vim.git "$XDG_DATA_HOME"/vim/bundle/Vundle.vim
    vim +BundleInstall +q +q
  fi
  # powerline font
  # TODO: add installation of custom font pkg (pkgs/otf-powerline-symbols)
  # for reference: how this was originally done, in case package doesn't work
  # wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf
  # wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf
  # mv PowerlineSymbols.otf ~/.local/share/fonts/
  # fc-cache -vf ~/.local/share/fonts/
  # mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/
}

# abs installs new packages and upgrades existing packages
abs () {
  mkdir -p $HOME/abs
  pkgs=(package-query)
  for pkg in "$pkgs[@]"; do
    cd $HOME/abs
    [ ! -d "$pkg" ] && git clone https://aur.archlinux.org/"$pkg".git
    cd "$pkg"
    git pull
    less PKGBUILD
    while true; do
      printf ":: Build package $pkg? (y/n/V) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          break ;;
        [Nn]|No|no|"" )
          print ":: Skipping..."
          continue 2 ;;
        [Vv]|View|view )
          less PKGBUILD ;;
        * ) ;;
      esac
    done
    # there should be a better way to do this, so that the package isn't rebuilt
    # if src hasn't changed, but I'm too lazy to figure it out right now.
    makepkg -isc
    git clean -fd
  done
}

# runs before update to save current state
backup () {
  # record last update date
  grep upgrade /var/log/pacman.log | tail -1 | cut -c 2-11 > $XDG_STATE_HOME/$PKGNAME/backup
}

update () {
  echo "update not implemented" >&2

  # update packages
  sudo pacman -Syyu
  abs

  # update package search
  sudo pacman -Fy
  sudo pkgfile -u

  # update vundle
  vim +BundleUpdate +q +q
}

restore () {
  # restore to previous date in case of bad update
  # https://wiki.archlinux.org/title/Arch_Linux_Archive#How_to_restore_all_packages_to_a_specific_date
  date="$(cat "$XDG_STATE_HOME/$PKGNAME/backup")"

  sudo mv /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
  mirrorlistcmd="echo \"Server=https://archive.archlinux.org/repos/$(print -r -- ${date//-/\/})/\\\$repo/os/\\\$arch\" > /etc/pacman.d/mirrorlist"
  sudo sh -c "$mirrorlistcmd"
  yes | pacman -Syyuu

  sudo mv /etc/pacman.d/mirrorlist.backup /etc/pacman.d/mirrorlist
}

config () {
  # Always include `local OPTIND` in any function that uses `getopts` otherwise
  #   all `getopts` share a single global OPTIND
  # https://stackoverflow.com/questions/63661198/zsh-getopts-optind-behavior-not-consistent-with-other-shells-bash-sh
  local OPTIND opt
  while getopts ":i:o:fc" opt; do
    case $opt in
      i) srcdir="$(realpath "$OPTARG")" ;;
      o) dstdir="$OPTARG" ;;
      f) force=true ;;
      c) copy=true ;;
      \?) echo "Invalid option -$OPTARG" >&2 && exit 1 ;;
    esac
  done

  # how to find symlinks referencing source:
  # $ find /home/ -type l -exec readlink -nf {} ';' -exec echo " -> {}" ';' | grep "/dir2"
  # TODO: find any files that might take precedence
  cfgs=(
        #dwb/
        #dwb/searchengines
        #dwb/settings
        #dwm/
        #dwm/dwm-diff.sh
        #dwm/dwm-grid-6.1.diff
        #dwm/dwm-svarog-6.1.diff
        #dwm/PKGBUILD
        #firefox/
        #firefox/chrome/
        #firefox/chrome/userChrome.css
        #firefox/chrome/userContent.css

        # TODO: add support for * operator
        #"global/environment:/etc/environment"
        "global/pacman.conf:/etc/pacman.conf"
        "global/profile:/etc/profile.d/user.sh"

        "dunstrc:$XDG_CONFIG_HOME/dunst/dunstrc"
        "fehbg:$XDG_CONFIG_HOME/fehbg"
        #"fonts.conf:$XDG_CONFIG_HOME/fontconfig/fonts.conf"
        "git/config:$XDG_CONFIG_HOME/git/config"
        "htoprc:$XDG_CONFIG_HOME/htop/htoprc"
        "inputrc:$HOME/.inputrc"                                       # TODO: make xdg-compliant
        "mpd.conf:$XDG_CONFIG_HOME/mpd/mpd.conf"
        "mpv.conf:$XDG_CONFIG_HOME/mpv/mpv.conf"
        # TODO: replace with ncmpcpp/*
        "ncmpcpp/bindings:$XDG_CONFIG_HOME/ncmpcpp/bindings"
        "ncmpcpp/config:$XDG_CONFIG_HOME/ncmpcpp/config"
        "ncmpcpp/patterns.list:$XDG_CONFIG_HOME/ncmpcpp/patterns.list"
        ".pam_environment:$HOME/.pam_environment"                      # TODO: make xdg-compliant
        "profile:$HOME/.profile"                                       # TODO: make xdg-compliant
        "tmux.conf:$XDG_CONFIG_HOME/tmux/tmux.conf"
        "user-dirs.dirs:$XDG_CONFIG_HOME/user-dirs.dirs"
        "vimrc:$XDG_CONFIG_HOME/vim/vimrc"
        "nvim/init.vim:$XDG_CONFIG_HOME/nvim/init.vim"
        ".xbindkeysrc:$HOME/.xbindkeysrc"                              # TODO: make xdg-compliant
        "xinitrc:$HOME/.xinitrc"                                       # TODO: make xdg-compliant
        "xres/urxvt:$XDG_CONFIG_HOME/X11/urxvt"
        "xres/colorsdark:$XDG_CONFIG_HOME/X11/colorsdark"
        "xresources:$XDG_CONFIG_HOME/X11/xresources"
        "zprofile:$HOME/.zprofile"                                     # TODO: make xdg-compliant
        "zshrc:$HOME/.zshrc"                                           # TODO: make xdg-compliant

        "bin/xstat:$HOME/bin/xstat"
      )

  [ "$copy" = true ] && print ":: Copying files..." || print ":: Linking files..."
  [ "$force" = true ] &&
    print ":: Overwriting existing files with -f"

  for (( i=1 ; i<=${#cfgs[@]} ; i++ )); do
    src="$(realpath -ms "$srcdir/${cfgs[$i]%%:*}")"
    dst="$(realpath -ms "$dstdir/${cfgs[$i]#*:}")"
    printf "(%d/%d) %s -> %s\n" "$i" "${#cfgs[@]}" "$src" "$dst"

    # find last element of path that already exists
    d="$dst"
    while [ ! -e "$d" ] || [ -h "$d" ]; do
      d="$(dirname "$d")"
    done

    # TODO: copy owner from file if already present, or directory if not
    # maybe not needed because files are just me / root
    #user=$(stat -c '%U' "$d")
    #group=$(stat -c '%G' "$d")

    [ -h "$dst" ] && filetype="symlink" ||
      { [ -d "$dst" ] && filetype="directory" } ||
      { [ -f "$dst" ] && filetype="file" }

    cmp --silent "$src" "$dst" &&
      { { [ -h "$dst" ] && [ "$(readlink -f "$dst")" = "$src" ] &&
          printf ":: Destination is symlink to source, " } ||
        { [ ! -h "$dst" ] &&
          printf ":: Destination and source are identical, " } } &&
      { [ "$force" = true ] && print "overwriting anyway with -f" ||
        { print "skipping" && continue } }

    overwrite= # reset in case set by previous iterations
    if [ -e "$dst" ]; then
      [ ! "$force" = true ] &&
        while true; do
          printf ":: Destination $filetype $(basename "$dst") exists, overwrite? (y/N) "
          read yn
          case $yn in
            [Yy]|Yes|yes )
              break ;;
            [Nn]|No|no|"" )
              print ":: Skipping..."
              continue 2 ;;
            * ) ;;
          esac
        done

      # TODO: figure out how to handle symlinks with copying with backups
      # -- currently copies contents into symlink
      cp $( [ -d "$dst" ] && echo "-r" ) -u --backup=numbered \
          --parents "$dst" "$CFG_BACKUP_DIR" &&
        print ":: Backed up $filetype to $(realpath "$CFG_BACKUP_DIR/$dst")" ||
        while true; do
          printf ":: Failed to back up $filetype, "
          [ "$force" = true ] && print "overwriting anyway with -f" && break ||
            printf "overwrite anyway? (y/N) "
          read yn
          case $yn in
            [Yy]|Yes|yes )
              break ;;
            [Nn]|No|no|"" )
              print ":: Skipping..."
              continue 2 ;;
            * ) ;;
          esac
        done
      overwrite=true
    fi

    sudo= # need to unset in case set on previous iteration
    if [ ! -w "$d" ]; then
      while [ -z "$root" ]; do
        printf ":: Missing write access for destination $d, continue as root? (Y/n) "
        read yn
        case $yn in
          [Yy]|Yes|yes|"" )
            root=true
            break ;;
          [Nn]|No|no )
            root=false
            break ;;
          * ) ;;
        esac
      done

      [ "$root" = true ] && sudo="sudo -E" ||
          {print ":: Root access required, skipping..." && continue }
    fi

    eval "$sudo mkdir -p \"$(dirname "$dst")\""
    eval "$sudo cp \"$src\" \"$dst\" \
        $( [ -h "$dst" ] && echo "--remove-destination") \
        $( [ "$overwrite" = true ] && echo "-f") \
        $( [ "$copy" = true ] || echo "-s") \
        2>/dev/null" &&
      { [ "$copy" = true ] &&
        print ":: Copied file" ||
        print ":: Created symbolic link" } ||
      { [ "$copy" = true ] &&
        print ":: Could not copy file" ||
        print ":: Could not create symbolic link" }
  done
}

hosts() {
  echo "hosts not implemented" >&2
}

fstab() {
  echo "fstab not implemented" >&2
}

# args=()
# opts=()
# while [ $OPTIND -le "$#" ]; do
#   if getopts b: opt; then
#     case $opt in
#       b) opts+=("$OPTARG");;
#     esac
#   else
#     args+=("${(P)OPTIND}")
#     # args+=("${!OPTIND}") -- bash
#     ((OPTIND++))
#   fi
# done
#
# echo "${args[@]}"
# echo "${opts[@]}"

readonly cmd=${1:?"The command must be specified."}
prereq
case $cmd in
  init) init "${@:2}" ;;
  install) install "${@:2}" ;;
  abs) abs "${@:2}" ;;
  backup) backup "${@:2}" ;;
  update) update "${@:2}" ;;
  restore) restore "${@:2}" ;;
  config) config -i "$REPO_DIR" -o / "${@:2}" ;;
  hosts) hosts "${@:2}" ;;
  fstab) fstab "${@:2}" ;;
  *) echo "Invalid command $cmd" >&2
    exit 1
esac
