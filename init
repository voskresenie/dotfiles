#!/usr/bin/env zsh
#
# This script initializes and maintains a system in a standardized format
#
# Usage:
# * TODO - install packages
# * TODO - update packages
# * config - copy or symlink conf files
# * TODO - set up hosts file
# * TODO - set up NFS connection in fstab file
#
# TODO: this is apparently bad for some reason, fix it
# http://mywiki.wooledge.org/BashFAQ/028
repo_dir="$(realpath "$(dirname "$0")")"
source "$repo_dir"/global/profile
source "$repo_dir"/profile

# these should already be set by one of the profile files, but might be worth
# keeping around anyway just in case
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-~/.config}"
XDG_STATE_HOME="${XDG_STATE_HOME:-~/.local/state}"
XDG_DATA_HOME="${XDG_DATA_HOME:-~/.local/share}"

pkgname=voskarch
state_dir="$XDG_STATE_HOME/$pkgname"
data_dir="$XDG_DATA_HOME/$pkgname"

# directory for backing up config files before overwriting
cfg_backup_dir="$state_dir/cfg/backup"
# file for keeping track of configs managed by script
cfg_state="$state_dir/cfg/managed"
# list of cfgs `src:dst` (potentially) managed by script
cfgs=(
      # TODO: add support for destination being a directory rather than filename
      # TODO: add support for * operator

      #dwb/
      #dwb/searchengines
      #dwb/settings
      #dwm/
      #dwm/dwm-diff.sh
      #dwm/dwm-grid-6.1.diff
      #dwm/dwm-svarog-6.1.diff
      #dwm/PKGBUILD
      #firefox/
      #firefox/chrome/
      #firefox/chrome/userChrome.css
      #firefox/chrome/userContent.css

      "global/pacman.conf:/etc/pacman.conf"
      "global/profile:/etc/profile.d/user.sh"

      "colors/env:$ZDOTDIR/colorsenv"
      "dunstrc:$XDG_CONFIG_HOME/dunst/dunstrc"
      "fehbg:$XDG_CONFIG_HOME/fehbg"
      #"fonts.conf:$XDG_CONFIG_HOME/fontconfig/fonts.conf"
      "git/config:$XDG_CONFIG_HOME/git/config"
      "htoprc:$XDG_CONFIG_HOME/htop/htoprc"
      "inputrc:$HOME/.inputrc"                                       # TODO: make xdg-compliant
      "mpd.conf:$XDG_CONFIG_HOME/mpd/mpd.conf"
      "mpv.conf:$XDG_CONFIG_HOME/mpv/mpv.conf"
      "ncmpcpp/bindings:$XDG_CONFIG_HOME/ncmpcpp/bindings"
      "ncmpcpp/config:$XDG_CONFIG_HOME/ncmpcpp/config"
      "ncmpcpp/patterns.list:$XDG_CONFIG_HOME/ncmpcpp/patterns.list"
      "profile:$HOME/.profile"                                       # TODO: make xdg-compliant
      "tmux.conf:$XDG_CONFIG_HOME/tmux/tmux.conf"
      "user-dirs.dirs:$XDG_CONFIG_HOME/user-dirs.dirs"
      "vim/vimrc:$XDG_CONFIG_HOME/vim/vimrc"
      "vim/colors.vim:$XDG_CONFIG_HOME/vim/colors/voskarch.vim"
      "vim/colors.airline.vim:$XDG_CONFIG_HOME/vim/autoload/airline/themes/voskarch.vim"
      "nvim/init.vim:$XDG_CONFIG_HOME/nvim/init.vim"
      "xbindkeysrc:$HOME/.xbindkeysrc"                               # TODO: make xdg-compliant
      "xinitrc:$HOME/.xinitrc"                                       # TODO: make xdg-compliant
      "X11/urxvt:$XDG_CONFIG_HOME/X11/urxvt"
      "X11/colorsdark:$XDG_CONFIG_HOME/X11/colorsdark"
      "X11/xresources:$XDG_CONFIG_HOME/X11/xresources"
      "zprofile:$HOME/.zprofile"                                     # TODO: make xdg-compliant
      "zshrc:$ZDOTDIR/.zshrc"                                        # TODO: see if it's possible to make it zshrc not .zshrc

      "bin/xstat:$HOME/bin/xstat"
    )

prereq () {
  mkdir -p "$cfg_backup_dir"

  source "$XDG_CONFIG_HOME"/user-dirs.dirs
  # TODO: this might be doable with xdg-user-dirs-update, unclear
  mkdir -p "$XDG_DESKTOP_DIR" \
    "$XDG_DOWNLOAD_DIR" \
    "$XDG_TEMPLATES_DIR" \
    "$XDG_PUBLICSHARE_DIR" \
    "$XDG_DOCUMENTS_DIR" \
    "$XDG_MUSIC_DIR" \
    "$XDG_PICTURES_DIR" \
    "$XDG_VIDEOS_DIR"
}

init () {
  if [ "$repo_dir" != "$(realpath -m "$data_dir")" ]; then
    while true; do
      printf ":: repo located at $repo_dir; move to $data_dir? (y/N) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          mkdir -p "$XDG_DATA_HOME"
          cp -r "$repo_dir" "$data_dir"
          cd "$data_dir"
          rm -rf "$repo_dir"
          repo_dir="$data_dir"
          print ":: new repo location: $repo_dir"
          break ;;
        [Nn]|No|no|"" ) break ;;
        * ) ;;
      esac
    done
  fi
}

install () {
  echo "install not implemented" >&2

  sudo pacman -Syyu
  pkgs=(pkgfile nano)
  sudo pacman -S "$pkgs[@]"
  abs

  # install vundle
  if [ ! -d "$XDG_DATA_HOME"/vim/bundle/Vundle.vim ]; then
    git clone https://github.com/VundleVim/Vundle.vim.git "$XDG_DATA_HOME"/vim/bundle/Vundle.vim
    vim +BundleInstall +q +q
  fi
  # powerline font
  # TODO: add installation of custom font pkg (pkgs/otf-powerline-symbols)
  # for reference: how this was originally done, in case package doesn't work
  # wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf
  # wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf
  # mv PowerlineSymbols.otf ~/.local/share/fonts/
  # fc-cache -vf ~/.local/share/fonts/
  # mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/
}

# abs installs new packages and upgrades existing packages
abs () {
  mkdir -p $HOME/abs
  pkgs=(package-query)
  for pkg in "$pkgs[@]"; do
    cd $HOME/abs
    [ ! -d "$pkg" ] && git clone https://aur.archlinux.org/"$pkg".git
    cd "$pkg"
    git pull
    less PKGBUILD
    while true; do
      printf ":: Build package $pkg? (y/n/V) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          break ;;
        [Nn]|No|no|"" )
          print ":: Skipping..."
          continue 2 ;;
        [Vv]|View|view )
          less PKGBUILD ;;
        * ) ;;
      esac
    done
    # there should be a better way to do this, so that the package isn't rebuilt
    # if src hasn't changed, but I'm too lazy to figure it out right now.
    makepkg -isc
    git clean -fd
  done
}

# runs before update to save current state
backup () {
  # record last update date
  grep upgrade /var/log/pacman.log | tail -1 | cut -c 2-11 > "$state_dir"/last_update
}

update () {
  echo "update not implemented" >&2

  # update packages
  sudo pacman -Syyu
  abs

  # update package search
  sudo pacman -Fy
  sudo pkgfile -u

  # update vundle
  vim +BundleUpdate +q +q
}

restore () {
  # restore to previous date in case of bad update
  # https://wiki.archlinux.org/title/Arch_Linux_Archive#How_to_restore_all_packages_to_a_specific_date
  date="$(cat "$state_dir"/last_update)"

  sudo mv /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
  mirrorlistcmd="echo \"Server=https://archive.archlinux.org/repos/$(print -r -- ${date//-/\/})/\\\$repo/os/\\\$arch\" > /etc/pacman.d/mirrorlist"
  sudo sh -c "$mirrorlistcmd"
  yes | pacman -Syyuu

  sudo mv /etc/pacman.d/mirrorlist.backup /etc/pacman.d/mirrorlist
}

request_root () {
  local __rootvar=${1:?"The root var must be specified."}
  eval local __root=$"$__rootvar"
  local msg=$2
  while [ -z "$__root" ]; do
    printf "$msg (Y/n) "
    read yn
    case $yn in
      [Yy]|Yes|yes|"" )
        __root=true
        break ;;
      [Nn]|No|no )
        __root=false
        break ;;
      * ) ;;
    esac
  done
  eval $__rootvar="'$__root'"
}

config () {
  # Always include `local OPTIND` in any function that uses `getopts` otherwise
  #   all `getopts` share a single global OPTIND
  # https://stackoverflow.com/questions/63661198/zsh-getopts-optind-behavior-not-consistent-with-other-shells-bash-sh
  local OPTIND opt
  local srcdir dstdir prmpt list clean force copy
  while getopts ":i:o:plcfx" opt; do
    case $opt in
      i) srcdir="$(realpath "$OPTARG")" ;;
      o) dstdir="$OPTARG" ;;
      p) prmpt=true ;;
      l) list=true ;;
      c) clean=true ;;
      f) force=true ;;
      x) copy=true ;;
      \?) echo "Invalid option -$OPTARG" >&2 && exit 1 ;;
    esac
  done

  local root sudo

  if [ "$list" = true ]; then
    print ":: Files managed by $pkgname $0:"
    [ -f "$cfg_state" ] && cat "$cfg_state"
    return
  fi

  if [ "$clean" = true ]; then
    print ":: Removing files managed by $pkgname $0:"
    if [ -f "$cfg_state" ]; then
      local tmp="$(mktemp)"
      #local existing_cfgs=( )
      #while read -r cfg; do
      #  existing_cfgs+=("$cfg")
      #done < "$cfg_state"
      local existing_cfgs=("${(@f)$(< "$cfg_state")}")

      for (( i=1 ; i<=${#existing_cfgs[@]} ; i++ )); do
        cfg="$existing_cfgs[$i]"
        printf "(%d/%d) %s\n" "$i" "${#existing_cfgs[@]}" "$cfg"
        cp -u --backup=numbered --parents "$cfg" "$cfg_backup_dir"
        if [ ! -w "$cfg" ] || { [ -h "$cfg" ] && [ ! -w "$(dirname "$cfg")" ] }; then
          request_root root ":: Missing write access for file, continue as root?"
          [ "$root" = true ] && sudo="sudo -E" ||
            {print ":: Root access required, skipping..." && print "$cfg" >> "$tmp" && continue }
        fi
        eval "$sudo rm \"$cfg\"" &&
          print ":: Removed config" ||
          { print ":: Could not remove config" && print "$cfg" >> "$tmp" }
      done
      mv "$tmp" "$cfg_state"
    fi
    exit
  fi

  # how to find symlinks referencing source:
  # $ find /home/ -type l -exec readlink -nf {} ';' -exec echo " -> {}" ';' | grep "/dir2"
  # TODO: find any files that might take precedence
  #
  # TODO: add detection for whether existing destination is NOT a symlink

  [ "$copy" = true ] && print ":: Copying files..." || print ":: Linking files..."
  [ "$force" = true ] &&
    print ":: Overwriting existing files with -f"

  local src dst d filetype overwrite
  for (( i=1 ; i<=${#cfgs[@]} ; i++ )); do
    src="$(realpath -ms "$srcdir/${cfgs[$i]%%:*}")"
    dst="$(realpath -ms "$dstdir/${cfgs[$i]#*:}")"
    printf "(%d/%d) %s -> %s\n" "$i" "${#cfgs[@]}" "$src" "$dst"

    # find last element of path that already exists
    d="$dst"
    while [ ! -e "$d" ] || [ -h "$d" ]; do
      d="$(dirname "$d")"
    done

    # TODO: copy owner from file if already present, or directory if not
    # maybe not needed because files are just me / root
    #user=$(stat -c '%U' "$d")
    #group=$(stat -c '%G' "$d")

    [ -h "$dst" ] && filetype="symlink" ||
      { [ -d "$dst" ] && filetype="directory" } ||
      { [ -f "$dst" ] && filetype="file" }

    cmp --silent "$src" "$dst" &&
      { { [ -h "$dst" ] && [ "$(readlink -f "$dst")" = "$src" ] &&
          printf ":: Destination is symlink to source, " } ||
        { [ ! -h "$dst" ] &&
          printf ":: Destination and source are identical, " } } &&
      { [ "$force" = true ] && print "overwriting anyway with -f" ||
        { print "skipping" && print "$dst" >> "$cfg_state" && continue } }

    [ "$prmpt" = true ] &&
      while true; do
        printf ":: %s file? (y/N) " $([ "$copy" = true ] && print "Copy" || print "Link")
        read yn
        case $yn in
          [Yy]|Yes|yes )
            break ;;
          [Nn]|No|no|"" )
            print ":: Skipping..."
            continue 2 ;;
          * ) ;;
        esac
      done

    overwrite= # reset in case set by previous iterations
    if [ -e "$dst" ]; then
      [ ! "$force" = true ] &&
        while true; do
          printf ":: Destination $filetype $(basename "$dst") exists, overwrite? (y/N) "
          read yn
          case $yn in
            [Yy]|Yes|yes )
              break ;;
            [Nn]|No|no|"" )
              print ":: Skipping..."
              continue 2 ;;
            * ) ;;
          esac
        done

      # TODO: figure out how to handle symlinks with copying with backups
      # -- currently copies contents into symlink
      cp $( [ -d "$dst" ] && echo "-r" ) -u --backup=numbered \
          --parents "$dst" "$cfg_backup_dir" &&
        print ":: Backed up $filetype to $(realpath "$cfg_backup_dir/$dst")" ||
        while true; do
          printf ":: Failed to back up $filetype, "
          [ "$force" = true ] && print "overwriting anyway with -f" && break ||
            printf "overwrite anyway? (y/N) "
          read yn
          case $yn in
            [Yy]|Yes|yes )
              break ;;
            [Nn]|No|no|"" )
              print ":: Skipping..."
              continue 2 ;;
            * ) ;;
          esac
        done
      overwrite=true
    fi

    if [ ! -w "$d" ]; then
      request_root root ":: Missing write access for destination $d, continue as root?"
      [ "$root" = true ] && sudo="sudo -E" ||
          {print ":: Root access required, skipping..." && continue }
    fi

    eval "$sudo mkdir -p \"$(dirname "$dst")\""
    eval "$sudo cp \"$src\" \"$dst\" \
        $( [ -h "$dst" ] && echo "--remove-destination") \
        $( [ "$overwrite" = true ] && echo "-f") \
        $( [ "$copy" = true ] || echo "-s") \
        2>/dev/null" &&
      { { print "$dst" >> "$cfg_state" } &&
        [ "$copy" = true ] &&
        print ":: Copied file" ||
        print ":: Created symbolic link" } ||
      { [ "$copy" = true ] &&
        print ":: Could not copy file" ||
        print ":: Could not create symbolic link" }
  done
  [ -f "$cfg_state" ] && sort -u "$cfg_state" -o "$cfg_state"
}

hosts() {
  echo "hosts not implemented" >&2
}

fstab() {
  echo "fstab not implemented" >&2
}

# args=()
# opts=()
# while [ $OPTIND -le "$#" ]; do
#   if getopts b: opt; then
#     case $opt in
#       b) opts+=("$OPTARG");;
#     esac
#   else
#     args+=("${(P)OPTIND}")
#     # args+=("${!OPTIND}") -- bash
#     ((OPTIND++))
#   fi
# done
#
# echo "${args[@]}"
# echo "${opts[@]}"

readonly cmd=${1:?"The command must be specified."}
prereq
case $cmd in
  init) init "${@:2}" ;;
  install) install "${@:2}" ;;
  abs) abs "${@:2}" ;;
  backup) backup "${@:2}" ;;
  update) update "${@:2}" ;;
  restore) restore "${@:2}" ;;
  config) config -i "$repo_dir" -o / "${@:2}" ;;
  hosts) hosts "${@:2}" ;;
  fstab) fstab "${@:2}" ;;
  *) echo "Invalid command $cmd" >&2
    exit 1
esac
