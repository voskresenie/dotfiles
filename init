#!/usr/bin/env zsh
#
# This script initializes and maintains a system in a standardized format
#
# Usage:
# * TODO - install packages
# * TODO - update packages
# * config - copy or symlink conf files
# * TODO - set up hosts file
# * TODO - set up NFS connection in fstab file
#
# TODO: this is apparently bad for some reason, fix it
# http://mywiki.wooledge.org/BashFAQ/028
repo_dir="$(realpath "$(dirname "$0")")"
source "$repo_dir"/global/profile
source "$repo_dir"/profile

source "$repo_dir"/colors/env
PREFIX="$BLUE::$RESET"

# these should already be set by one of the profile files, but might be worth
# keeping around anyway just in case
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-~/.config}"
XDG_STATE_HOME="${XDG_STATE_HOME:-~/.local/state}"
XDG_DATA_HOME="${XDG_DATA_HOME:-~/.local/share}"

pkgname=voskarch
state_dir="$XDG_STATE_HOME/$pkgname"
data_dir="$XDG_DATA_HOME/$pkgname"

# directory for backing up config files before overwriting
cfg_backup_dir="$state_dir/cfg/backup"
# file for keeping track of configs managed by script
cfg_state="$state_dir/cfg/managed"
# list of cfgs `src:dst` (potentially) managed by script
cfgs=(
      # TODO: add support for destination being a directory rather than filename
      # TODO: add support for * operator

      #dwb/
      #dwb/searchengines
      #dwb/settings
      #dwm/
      #dwm/dwm-diff.sh
      #dwm/dwm-grid-6.1.diff
      #dwm/dwm-svarog-6.1.diff
      #dwm/PKGBUILD
      #firefox/
      #firefox/chrome/
      #firefox/chrome/userChrome.css
      #firefox/chrome/userContent.css

      "global/pacman.conf:/etc/pacman.conf"
      "global/profile:/etc/profile.d/user.sh"
      "global/sysctl.d/disable_ipv6.conf:/etc/sysctl.d/disable_ipv6.conf"

      "colors/env:$ZDOTDIR/colorsenv"
      "dunstrc:$XDG_CONFIG_HOME/dunst/dunstrc"
      "fehbg:$XDG_CONFIG_HOME/fehbg"
      #"fonts.conf:$XDG_CONFIG_HOME/fontconfig/fonts.conf"
      "git/config:$XDG_CONFIG_HOME/git/config"
      "htoprc:$XDG_CONFIG_HOME/htop/htoprc"
      "inputrc:$HOME/.inputrc"                                       # TODO: make xdg-compliant
      "mpd.conf:$XDG_CONFIG_HOME/mpd/mpd.conf"
      "mpv.conf:$XDG_CONFIG_HOME/mpv/mpv.conf"
      "ncmpcpp/bindings:$XDG_CONFIG_HOME/ncmpcpp/bindings"
      "ncmpcpp/config:$XDG_CONFIG_HOME/ncmpcpp/config"
      "ncmpcpp/patterns.list:$XDG_CONFIG_HOME/ncmpcpp/patterns.list"
      "profile:$HOME/.profile"                                       # TODO: make xdg-compliant
      "redshift.conf:$XDG_CONFIG_HOME/redshift.conf"
      "tmux.conf:$XDG_CONFIG_HOME/tmux/tmux.conf"
      "user-dirs.dirs:$XDG_CONFIG_HOME/user-dirs.dirs"
      "vim/vimrc:$XDG_CONFIG_HOME/vim/vimrc"
      "vim/colors.vim:$XDG_CONFIG_HOME/vim/colors/voskarch.vim"
      "vim/colors.airline.vim:$XDG_CONFIG_HOME/vim/autoload/airline/themes/voskarch.vim"
      "nvim/init.vim:$XDG_CONFIG_HOME/nvim/init.vim"
      "X11/colorsdark:$XDG_CONFIG_HOME/X11/colorsdark"
      "X11/urxvt:$XDG_CONFIG_HOME/X11/urxvt"
      "X11/xbindkeysrc:$HOME/.xbindkeysrc"                               # TODO: make xdg-compliant
      "X11/xinitrc:$HOME/.xinitrc"                                       # TODO: make xdg-compliant
      "X11/xresources:$XDG_CONFIG_HOME/X11/xresources"
      "zprofile:$HOME/.zprofile"                                     # TODO: make xdg-compliant
      "zshrc:$ZDOTDIR/.zshrc"                                        # TODO: see if it's possible to make it zshrc not .zshrc

      "bin/xstat:$HOME/bin/xstat"
    )

prereq () {
  mkdir -p "$cfg_backup_dir"

  source "$XDG_CONFIG_HOME"/user-dirs.dirs
  # TODO: this might be doable with xdg-user-dirs-update, unclear
  mkdir -p "$XDG_DESKTOP_DIR" \
    "$XDG_DOWNLOAD_DIR" \
    "$XDG_TEMPLATES_DIR" \
    "$XDG_PUBLICSHARE_DIR" \
    "$XDG_DOCUMENTS_DIR" \
    "$XDG_MUSIC_DIR" \
    "$XDG_PICTURES_DIR" \
    "$XDG_VIDEOS_DIR"
}

init () {
  if [ "$repo_dir" != "$(realpath -m "$data_dir")" ]; then
    while true; do
      printf "$PREFIX repo located at $repo_dir; move to $data_dir? (y/N) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          mkdir -p "$XDG_DATA_HOME"
          cp -r "$repo_dir" "$data_dir"
          cd "$data_dir"
          rm -rf "$repo_dir"
          repo_dir="$data_dir"
          print "$PREFIX new repo location: $repo_dir"
          break ;;
        [Nn]|No|no|"" ) break ;;
        * ) ;;
      esac
    done
  fi
}

install () {
  echo "install not implemented" >&2

  sudo pacman -Syyu
  pkgs=(pkgfile nano)
  sudo pacman -S "$pkgs[@]"
  abs

  # install vundle
  if [ ! -d "$XDG_DATA_HOME"/vim/bundle/Vundle.vim ]; then
    git clone https://github.com/VundleVim/Vundle.vim.git "$XDG_DATA_HOME"/vim/bundle/Vundle.vim
    vim +BundleInstall +q +q
  fi
  # powerline font
  # TODO: add installation of custom font pkg (pkgs/otf-powerline-symbols)
  # for reference: how this was originally done, in case package doesn't work
  # wget https://github.com/powerline/powerline/raw/develop/font/PowerlineSymbols.otf
  # wget https://github.com/powerline/powerline/raw/develop/font/10-powerline-symbols.conf
  # mv PowerlineSymbols.otf ~/.local/share/fonts/
  # fc-cache -vf ~/.local/share/fonts/
  # mv 10-powerline-symbols.conf ~/.config/fontconfig/conf.d/
}

# abs installs new packages and upgrades existing packages
abs () {
  mkdir -p $HOME/abs
  pkgs=(package-query)
  for pkg in "$pkgs[@]"; do
    cd $HOME/abs
    [ ! -d "$pkg" ] && git clone https://aur.archlinux.org/"$pkg".git
    cd "$pkg"

    # skip if up to date
    [ $(git pull --dry-run | wc -l) -eq 0 ] && continue

    git pull
    less PKGBUILD
    while true; do
      printf "$PREFIX Build package $pkg? (y/n/V) "
      read yn
      case $yn in
        [Yy]|Yes|yes )
          break ;;
        [Nn]|No|no|"" )
          print "$PREFIX Skipping..."
          continue 2 ;;
        [Vv]|View|view )
          less PKGBUILD ;;
        * ) ;;
      esac
    done
    # there should be a better way to do this, so that the package isn't rebuilt
    # if src hasn't changed, but I'm too lazy to figure it out right now.
    makepkg -isc
    git clean -fd
  done
}

# runs before update to save current state
backup () {
  # record last update date
  grep upgrade /var/log/pacman.log | tail -1 | cut -c 2-11 > "$state_dir"/last_update
}

orphan-deps () {
  local OPTIND opt
  local quiet verbose=false
  while getopts ":qv" opt; do
    case $opt in
      q) quiet=true ;;
      v) verbose=true ;;
      \?) echo "Invalid option -$OPTARG" >&2 && exit 1 ;;
    esac
  done

  local orphs=$(pacman -Qtdq | wc -l)
  [ ! "$quiet" = true ] && [ "$orphs" -eq 0 ] && print " no orphaned dependencies"
  [ "$orphs" -ne 0 ] && warn "$orphs orphaned dependencies"
  [ "$verbose" = true ] && pacman -Qtdq
  return 0
}

update () {
  local OPTIND opt
  local quiet verbose=false
  while getopts ":qv" opt; do
    case $opt in
      q) quiet=true ;;
      v) verbose=true ;;
      \?) echo "Invalid option -$OPTARG" >&2 && exit 1 ;;
    esac
  done

  # "description:normal command:[quiet command]:[verbose command]"
  local cmds=(
              'Updating package database:sudo pacman -Sy::'
              #'Updating package keys:sudo pacman-key --refresh-keys::'
              #'Updating package keys:sudo pacman-key --updatedb::'
              'Updating package keys:sudo pacman -S archlinux-keyring:yes | sudo pacman --color always -S archlinux-keyring 1>/dev/null:'
              'Updating packages:sudo pacman -Su:yes | sudo pacman --color always -Su 1>/dev/null 2>/dev/null:'
              'Updating package search:sudo pacman -Fy::' # possibly redundant with -Sy
              'Checking for orphaned dependencies:orphan-deps:orphan-deps -q:orphan-deps -v'
              'Updating abs:abs:false:'
              'Updating pkgfile:sudo pkgfile -u 1>/dev/null::'
              'Updating mlocate db:sudo updatedb::'
              'Updating vundle:nvim +BundleUpdate +q +q::'
              'Syncing hwclock with ntpd:__out=$(sudo ntpd -qg) && sudo hwclock --systohc && print $__out | tail -n 1::sudo ntpd -qg 1>/dev/null && sudo hwclock --systohc'
              )
  for (( i=1 ; i<=${#cmds[@]} ; i++ )); do
    parts=("${(@s[:])cmds[$i]}")
    desc="$parts[1]"
    cmd="$parts[2]"
    if [ "$quiet" = true ]; then
      [ "$parts[3]" = false ] && print "$PREFIX $desc -- skipping in quiet mode" && continue
      [ -n "$parts[3]" ] && cmd="$parts[3]" || cmd="$cmd 1>/dev/null"
    elif [ "$verbose" = true ]; then
      [ -n "$parts[4]" ] && cmd="$parts[4]"
    fi
    print "$PREFIX $desc..."
    veval $verbose "$cmd" ||
      { print "$PREFIX Failed to complete update" && return }
  done
  print "$PREFIX Successfully updated system"
}

restore () {
  # restore to previous date in case of bad update
  # https://wiki.archlinux.org/title/Arch_Linux_Archive#How_to_restore_all_packages_to_a_specific_date
  date="$(cat "$state_dir"/last_update)"

  sudo mv /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
  mirrorlistcmd="echo \"Server=https://archive.archlinux.org/repos/$(print -r -- ${date//-/\/})/\\\$repo/os/\\\$arch\" > /etc/pacman.d/mirrorlist"
  sudo sh -c "$mirrorlistcmd"
  yes | pacman -Syyuu

  sudo mv /etc/pacman.d/mirrorlist.backup /etc/pacman.d/mirrorlist
}

# error
#
# usage: error MESSAGE
#
error () {
  local __msg="${@:1}"
  print >&2 "${RED}error:$RESET $__msg"
}

# warn
#
# usage: warn MESSAGE
#
warn () {
  local __msg="${@:1}"
  print >&2 "${YELLOW}warning:$RESET $__msg"
}

# verbose print
#
# usage: vprint VERBOSE MESSAGE...
#
# Usage same as print. VERBOSE param, if taken from a variable, should be quoted
# if there is a chance it will be null. Evaluates to true even if VERBOSE is
# false. This makes it simpler to chain together with other commands, eg
#   command && vprint $v $success_msg || print $failure_msg
# where the goal is to print a success message only if verbose logging is
# enabled, but print a failure message whether verbose logging is enabled or
# not. If vprint evaluated to false when verbose is false, this functionality
# wouldn't be possible in shorthand except through something gross like
#  command && { vprint $v $success_msg || true } || print $failure_msg
# which is the exact sort of use case vprint exists to avoid.
#
vprint () {
  local __verbose="$1"
  local __msg=${@:2}
  [ "$__verbose" = true ] && [ -n "$__msg" ] && print $__msg || true
}

# verbose eval
#
# usage: veval VERBOSE? CMD...
#
# Usage same as eval (ie command may require escaping). VERBOSE param, if taken
# from a variable, should be quoted if there is a chance it will be null.
#
veval () {
  local __verbose="$1"
  local __cmd="${@:2}"
  if [ "$__verbose" = true ]; then
    [ -n "$__cmd" ] && print "$__cmd"
  fi
  eval $__cmd
}

request_root () {
  local __rootvar=${1:?"The root var must be specified."}
  eval local __root=$"$__rootvar"
  local msg=$2
  while [ -z "$__root" ]; do
    printf "$msg (Y/n) "
    read yn
    case $yn in
      [Yy]|Yes|yes|"" )
        __root=true
        break ;;
      [Nn]|No|no )
        __root=false
        break ;;
      * ) ;;
    esac
  done
  eval $__rootvar="'$__root'"
}

config () {
  # Always include `local OPTIND` in any function that uses `getopts` otherwise
  #   all `getopts` share a single global OPTIND
  # https://stackoverflow.com/questions/63661198/zsh-getopts-optind-behavior-not-consistent-with-other-shells-bash-sh
  local OPTIND opt
  local prmpt list clean copy force verbose=false
  while getopts ":plcxfv" opt; do
    case $opt in
      p) prmpt=true ;;
      l) list=true ;;
      c) clean=true ;;
      x) copy=true ;;
      f) force=true ;;
      v) verbose=true ;;
      \?) echo "Invalid option -$OPTARG" >&2 && exit 1 ;;
    esac
  done

  local root sudo

  if [ "$list" = true ]; then
    print "$PREFIX Files managed by $pkgname $0:"
    [ -f "$cfg_state" ] && cat "$cfg_state"
    return
  fi

  if [ "$clean" = true ]; then
    print "$PREFIX Removing files managed by $pkgname $0:"
    if [ -f "$cfg_state" ]; then
      local tmp="$(mktemp)"
      local existing_cfgs=("${(@f)$(< "$cfg_state")}")

      for (( i=1 ; i<=${#existing_cfgs[@]} ; i++ )); do
        cfg="$existing_cfgs[$i]"
        printf "(%d/%d) %s\n" "$i" "${#existing_cfgs[@]}" "$cfg"

        vprint $verbose "$PREFIX Backing up file before removing"
        veval $verbose cp -u --backup=numbered --parents \"$cfg\" \"$cfg_backup_dir\"

        sudo= # reset in case set by previous iterations
        if [ ! -w "$cfg" ] || { [ -h "$cfg" ] && [ ! -w "$(dirname "$cfg")" ] }; then
          request_root root "$PREFIX Missing write access for file, continue as root?"
          [ "$root" = true ] && sudo="sudo -E" || {
            print "$PREFIX Root access required, skipping..."
            vprint $verbose "$PREFIX Writing filename to temporary file to be preserved in config state file"
            veval $verbose print \"$cfg\" ">>" \"$tmp\"
            continue
          }
        fi
        vprint $verbose "$PREFIX Removing config$([ -n "$sudo" ] && print " as root")"
        veval $verbose $sudo rm \"$cfg\" || {
          print "$PREFIX Could not remove config"
          vprint $verbose "$PREFIX Writing filename to temporary file to be preserved in config state file"
          veval $verbose print \"$cfg\" ">>" \"$tmp\"
        }
      done
      vprint $verbose "$PREFIX Replacing config state file with temporary file"
      veval $verbose mv \"$tmp\" \"$cfg_state\"
    fi
    exit
  fi

  # how to find symlinks referencing source:
  # $ find /home/ -type l -exec readlink -nf {} ';' -exec echo " -> {}" ';' | grep "/dir2"
  # TODO: find any files that might take precedence
  #
  # TODO: add detection for whether existing destination is NOT a symlink

  [ "$copy" = true ] && vprint $verbose "$PREFIX Copying files..." || vprint $verbose "$PREFIX Linking files..."
  [ "$force" = true ] && vprint $verbose "$PREFIX Overwriting existing files with -f"

  local src dst d filetype overwrite
  for (( i=1 ; i<=${#cfgs[@]} ; i++ )); do
    src="$(realpath -ms "$repo_dir/${cfgs[$i]%%:*}")"
    dst="$(realpath -ms "${cfgs[$i]#*:}")"
    printf "(%d/%d) %s -> %s\n" "$i" "${#cfgs[@]}" "$src" "$dst"

    [ -h "$dst" ] && filetype="symlink" ||
      { [ -d "$dst" ] && filetype="directory" } ||
      { [ -f "$dst" ] && filetype="file" }

    vprint $verbose "$PREFIX Comparing source to destination"
    veval $verbose cmp --silent \"$src\" \"$dst\" &&
      { { [ -h "$dst" ] && [ ! "$copy" = true ] && [ "$(readlink -f "$dst")" = "$src" ] &&
          msg="Destination is symlink to source" } ||
        { [ ! -h "$dst" ] && [ "$copy" = true ] &&
          msg="Destination and source are identical" } } &&
      { [ "$force" = true ] && vprint $verbose "$PREFIX $msg, overwriting anyway with -f" ||
        { vprint $verbose "$msg, skipping" &&
          vprint $verbose "$PREFIX Adding to config state file" &&
          veval $verbose print \"$dst\" ">>" \"$cfg_state\" &&
          continue } }

    [ "$prmpt" = true ] &&
      while true; do
        printf "$PREFIX %s file? (y/N) " $([ "$copy" = true ] && print "Copy" || print "Link")
        read yn
        case $yn in
          [Yy]|Yes|yes )
            break ;;
          [Nn]|No|no|"" )
            vprint $verbose "$PREFIX Skipping..."
            continue 2 ;;
          * ) ;;
        esac
      done

    overwrite= # reset in case set by previous iterations
    if [ -e "$dst" ] || [ -h "$dst" ]; then
      [ ! "$force" = true ] &&
        while true; do
          printf "$PREFIX Destination $filetype $(basename "$dst") exists, overwrite? (y/N) "
          read yn
          case $yn in
            [Yy]|Yes|yes )
              break ;;
            [Nn]|No|no|"" )
              vprint $verbose "$PREFIX Skipping..."
              continue 2 ;;
            * ) ;;
          esac
        done

      # TODO: figure out how to handle symlinks with copying with backups
      # -- currently copies contents into symlink
      cmd="cp $( [ -d "$dst" ] && echo "-r" ) -u --backup=numbered --parents \"$dst\" \"$cfg_backup_dir\""
      vprint $verbose "$PREFIX Backing up existing $filetype before overwriting"
      veval $verbose $cmd &&
        vprint $verbose "$PREFIX Backed up $filetype to $(realpath "$cfg_backup_dir/$dst")" ||
        { [ "$force" = true ] &&
            vprint $verbose "$PREFIX Failed to back up $filetype, overwriting anyway with -f" ||
            while true; do
              printf "$PREFIX Failed to back up $filetype, overwrite anyway? (y/N) "
              read yn
              case $yn in
                [Yy]|Yes|yes )
                  break ;;
                [Nn]|No|no|"" )
                  print "$PREFIX Skipping..."
                  continue 2 ;;
                * ) ;;
              esac
            done }
      overwrite=true
    fi

    # find last element of path that already exists
    d="$dst"
    while [ ! -e "$d" ] || [ -h "$d" ]; do
      d="$(dirname "$d")"
    done

    # TODO: copy owner from file if already present, or directory if not
    # maybe not needed because files are just me / root
    #user=$(stat -c '%U' "$d")
    #group=$(stat -c '%G' "$d")

    sudo= # reset in case set by previous iterations
    if [ ! -w "$d" ]; then
      request_root root "$PREFIX Missing write access for destination $d, continue as root?"
      [ "$root" = true ] && sudo="sudo -E" ||
          { print "$PREFIX Root access required, skipping..." && continue }
    fi

    vprint $verbose "$PREFIX Making missing directories in path"
    veval $verbose $sudo mkdir -p \"$(dirname "$dst")\"
    veval $verbose "$sudo cp \"$src\" \"$dst\" \
      $( [ -h "$dst" ] && echo "--remove-destination") \
      $( [ "$overwrite" = true ] && echo "-f") \
      $( [ "$copy" = true ] || echo "-s") \
      2>/dev/null" &&
      { vprint $verbose "$PREFIX Adding to config state file" &&
        veval $verbose print \"$dst\" ">>" \"$cfg_state\" &&
        [ "$copy" = true ] &&
        vprint $verbose "$PREFIX Copied file" ||
        vprint $verbose "$PREFIX Created symbolic link" } ||
      { [ "$copy" = true ] &&
        print "$PREFIX Could not copy file" ||
        print "$PREFIX Could not create symbolic link" }
  done
  [ -f "$cfg_state" ] && sort -u "$cfg_state" -o "$cfg_state"
}

hosts() {
  echo "hosts not implemented" >&2
}

fstab() {
  echo "fstab not implemented" >&2
}

# args=()
# opts=()
# while [ $OPTIND -le "$#" ]; do
#   if getopts b: opt; then
#     case $opt in
#       b) opts+=("$OPTARG");;
#     esac
#   else
#     args+=("${(P)OPTIND}")
#     # args+=("${!OPTIND}") -- bash
#     ((OPTIND++))
#   fi
# done
#
# echo "${args[@]}"
# echo "${opts[@]}"

readonly initcmd=${1:?"The command must be specified."}
prereq
case $initcmd in
  init) init "${@:2}" ;;
  install) install "${@:2}" ;;
  abs) abs "${@:2}" ;;
  backup) backup "${@:2}" ;;
  update) update "${@:2}" ;;
  restore) restore "${@:2}" ;;
  config) config "${@:2}" ;;
  hosts) hosts "${@:2}" ;;
  fstab) fstab "${@:2}" ;;
  *) echo "Invalid command $initcmd" >&2
    exit 1
esac
